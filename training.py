'''
training.py

This trains the model to identify whether it is
a malware
'''
import os.path
import pickle
import warnings

import numpy as np

from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import Perceptron
from sklearn.neural_network import MLPClassifier
from sklearn.ensemble import BaggingClassifier
from sklearn.neighbors import KNeighborsClassifier

from sklearn.model_selection import train_test_split
from sklearn.metrics import roc_curve, auc

import matplotlib.pyplot as plt

warnings.simplefilter("ignore")
from sklearn.model_selection import KFold, cross_val_score

from utilities import get_data_directory

def get_classifier(API_lvl=22, classfier_type="Random_Forest"):
    classfier_path = get_data_directory("training_data", "API_{}".format(API_lvl),
    "API_{}_{}".format(API_lvl, classfier_type))

    assert os.path.exists(classfier_path), "Classifier does not exist. Do you want to train a new one?"

    with open(classfier_path, "rb") as pickle_can:
        clf = pickle.load(pickle_can)
        return clf

def make_prediction(classifier, vector, classifier_type="All"):

    assertion_message = "The vector size should match the size of data you trained"
    if classifier_type == "All":
        assert len(vector) == 750, assertion_message
    elif classifier_type == "API Only":
        assert len(vector) == 600, assertion_message
    elif classifier_type == "Permission Only":
        assert len(vector) == 150, assertion_message

    return {
        "Prediction Result"    : classifier.predict([vector]),
        "Confidential Interval": classifier.predict_proba([vector])[:,-1]
    }


def generate_roc_curve(classifier, X, y):
    prediction = classifier.predict_proba(X)

    fpr, tpr, thresholds = roc_curve(y, prediction[:, 1])
    roc_auc = auc(fpr, tpr)

    with plt.style.context('ggplot', after_reset=True):
        plt.title("ROC Curve for Random Forest, Feature=All")
        plt.plot(fpr, tpr,
        label='Classifier ROC (auc = %0.2f)' % (roc_auc))

        plt.plot([0, 1], [0, 1], linestyle='--',
        label='Random Guessing')

        plt.legend()
        plt.savefig("test.png", dpi=300)

def training_model(API_level=22, 
                   dump_model=True,
                   load_model=False,
                   model_location=None,
                   full_train=False, 
                   feature_selection="All", 
                   model_name="Random Forest", **model_param):

    if load_model:
        assert not (model_location is None), "You have to tell where the <pickled> model is"

    data_path = get_data_directory("training_data", "API_{}".format(API_level), 
    "API_{}_training_final.txt".format(API_level))

    huge_data = np.loadtxt(data_path)

    if feature_selection == "All":
        X = huge_data[:, :-1]

    elif feature_selection == "Permission Only":
        X = huge_data[:, :150]
    
    elif feature_selection == "API Only":
        X = huge_data[:, 150:-1]

    y = huge_data[:, -1]

    if not full_train:
        X_train, X_test, Y_train, Y_test = train_test_split(X, y, shuffle=True, train_size=0.9)
    
    else:
        X_train, X_test, Y_train, Y_test = X, None, y, None

    k_fold = KFold(len(Y_train), n_folds=10, shuffle=True, random_state=0)

    if not load_model:
        if model_name == "Random Forest":
            clf = RandomForestClassifier(**model_param)

        elif model_name == "Neural Network":
            clf = MLPClassifier(**model_param)
    else:
        with open(model_location, "rb") as pickle_can:
            clf = pickle.load(pickle_can)

    score_list = cross_val_score(clf, X_train, Y_train, cv=k_fold, n_jobs=1, scoring="accuracy")
    print("[Model   Name] ", model_name)
    print("[Trained with] {:5d} samples".format(len(X_train)))
    print("Ten Fold Cross Validation Accuracy : {:.2%} (+/-{:.2%})".format(np.mean(score_list), np.std(score_list)))

    clf.fit(X_train, Y_train)

    if not full_train:
        generate_roc_curve(clf, X_test, Y_test)

    if dump_model:

        pickle_to = get_data_directory("training_data", "API_{}".format(API_level), 
        "API_{}_{}".format(API_level, "_".join(model_name.split())))

        with open(pickle_to, "wb") as pickle_can:
            pickle.dump(clf, pickle_can)
    
    return clf

if __name__ == "__main__":
    training_model(feature_selection="All")




